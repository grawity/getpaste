#!/usr/bin/env perl
# getpaste - retrieves raw text from pastebins
#
# (c) 2010-2015 Mantas MikulÄ—nas <grawity@gmail.com>
# Released under the MIT license (see dist/LICENSE.mit)
use warnings;
use strict;
no locale;
use Getopt::Long qw(:config bundling no_ignore_case);
use JSON;
use LWP::UserAgent;
use MIME::Base64;

BEGIN {
	if (eval {require Nullroute::Lib}) {
		Nullroute::Lib->import(qw(_debug _warn _err _die));
	} else {
		our ($arg0, $warnings, $errors);
		$::arg0 = (split m!/!, $0)[-1];
		$::debug = !!$ENV{DEBUG};
		sub _debug { warn "debug: @_\n" if $::debug; }
		sub _warn  { warn "warning: @_\n"; ++$::warnings; }
		sub _err   { warn "error: @_\n"; ! ++$::errors; }
		sub _die   { _err(@_); exit 1; }
	}
}

sub _prompt {
	my $msg = shift;
	print STDERR "\e[1m$msg\e[m "; $|++;
	chomp(my $resp = <STDIN>);
	$resp;
}

my $UA = LWP::UserAgent->new;

sub uri_split {
	my $str = shift;

	# stolen from URI::Split
	$str =~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,;
}

sub get {
	my $url = shift;

	_debug("fetching '$url'");
	my $resp = $UA->get($url);

	if ($resp->is_success) {
		_debug("fetch complete: '".$resp->status_line."'");
		return $resp->decoded_content // $resp->content;
	} else {
		_err("fetch failed: '".$resp->status_line."'");
		return undef;
	}
}

sub getprint {
	my ($url) = @_;

	my $data = get($url);
	if (defined $data) {
		print $data;
	}
}

sub post {
	my ($url, %form) = @_;

	_debug("posting to '$url'");
	my $resp = $UA->post($url, \%form);

	if ($resp->is_success) {
		_debug("post complete: '".$resp->status_line."'");
		return $resp->decoded_content // $resp->content;
	} else {
		_err("post failed: '".$resp->status_line."'");
		return undef;
	}
}

sub decode_sour_base64 {
	my ($str) = @_;

	$str =~ y!_-!/+!;
	return decode_base64($str);
}

sub decode_html {
	my $str = shift;

	$str =~ s/&lt;/</g;
	$str =~ s/&gt;/>/g;
	$str =~ s/&quot;/"/g;
	$str =~ s/&amp;/\&/g;
	return $str;
}

sub try_decode_json {
	my $data = shift;

	return ref $data ? $data : decode_json($data);
}

sub EVP_BytesToKey {
	eval {
		require Crypt::Digest::MD5;
	} or _die("missing Perl package 'CryptX'");

	Crypt::Digest::MD5->import("md5");

	my ($salt, $passphrase, $ks, $ivs) = @_;

	my $hash = "";
	my $buf = "";

	while (length($buf) < $ks + $ivs) {
		$hash = md5($hash, $passphrase, $salt);
		$buf .= $hash;
	}

	my $key = substr($buf, 0, $ks);
	my $iv = substr($buf, $ks, $ivs);

	return ($key, $iv);
}

sub decrypt_sjcl {
	eval {
		require Crypt::AuthEnc::CCM;
		require Crypt::KeyDerivation;
	} or _die("missing Perl package 'CryptX'");

	Crypt::AuthEnc::CCM->import(":all");
	Crypt::KeyDerivation->import("pbkdf2");

	# serialization: JSON
	# key derivation: PBKDF2-SHA256
	# encryption: AES128-CCM

	my ($frag, $json) = @_;

	my $data = try_decode_json($json);

	if (($data->{v} //= "1") != 1) {
		_die("unsupported SJCL blob version ".$data->{v});
	}
	if (($data->{cipher} //= "aes") ne "aes") {
		_die("unsupported cipher ".$data->{cipher});
	}
	if (($data->{mode} //= "ccm") ne "ccm") {
		_die("unsupported mode ".$data->{mode});
	}

	my $salt = decode_base64($data->{salt});
	my $ct   = decode_base64($data->{ct});
	my $iv   = decode_base64($data->{iv});
	my $iter = int($data->{iter} || 1000),
	my $ks   = int($data->{ks} || 128) / 8; # key size
	my $ts   = int($data->{ts} || 64) / 8; # tag size
	my $hdr  = decode_base64($data->{adata} // "");

	my $key  = pbkdf2($frag, $salt, $iter, "SHA256", $ks);
	my $tag  = substr($ct, -$ts, $ts, "");

	return ccm_decrypt_verify("AES", $key, $iv, $hdr, $ct, $tag)
	       // _die("decryption failed");
}

sub decrypt_ezcrypt {
	eval {
		require Crypt::Cipher::AES;
		require Crypt::KeyDerivation;
		require Crypt::Mode::OFB;
	} or _die("missing Perl package 'CryptX'");

	Crypt::KeyDerivation->import("pbkdf2");

	# serialization: raw [salt + data]
	# key derivation: PBKDF2-SHA1
	# encryption: AES-256-OFB

	my ($frag, $data) = @_;

	my $ks   = Crypt::Cipher::AES->keysize;
	my $bs   = Crypt::Cipher::AES->blocksize;

	my $salt = substr($data, 0, $bs, "");
	my $iter = 1; # LOL
	my $key  = pbkdf2($frag, $salt, $iter, "SHA1", $ks);
	my $iv   = $salt;

	return Crypt::Mode::OFB->new("AES")->decrypt($data, $key, $iv);
}

sub decrypt_sour {
	eval {
		require Crypt::Cipher::AES;
		require Crypt::Mode::CBC;
	} or _die("missing Perl package 'CryptX'");

	# serialization: raw [magic + salt + data]
	# key derivation: EVP_BytesToKey (MD5)
	# encryption: AES-256-CBC

	my ($frag, $data) = @_;

	my $ks    = Crypt::Cipher::AES->keysize;
	my $bs    = Crypt::Cipher::AES->blocksize;

	my $magic = substr($data, 0, 8, "");
	my $salt  = substr($data, 0, 8, "");

	if ($magic ne "Salted__") {
		_die("bad magic value in encrypted data");
	}
	my ($key, $iv) = EVP_BytesToKey($salt, $frag, $ks, $bs);

	return Crypt::Mode::CBC->new("AES")->decrypt($data, $key, $iv);
}

sub decompress_lzw {
	eval {
		require Compress::LZW;
	} or _die("missing Perl package 'Compress::LZW'");

	my ($buf) = @_;

	return Compress::LZW->decompress($buf);
}

sub decompress_deflate {
	eval {
		require Compress::Raw::Zlib;
	} or _die("missing Perl package 'Compress::Raw::Zlib'");

	my ($buf, %opt) = @_;

	my $wbits;
	my $stream;
	my $status;
	my $outbuf;

	if ($opt{is_gzip}) {
		$wbits = Compress::Raw::Zlib->WANT_GZIP;
	} else {
		$wbits = -Compress::Raw::Zlib->MAX_WBITS;
	}

	($stream, $status) = Compress::Raw::Zlib::Inflate->new(-WindowBits => $wbits);
	if ($status != Compress::Raw::Zlib->Z_OK) {
		_die("inflateInit failed: $status");
	}

	$status = $stream->inflate($buf, $outbuf);
	if ($status != Compress::Raw::Zlib->Z_OK &&
	    $status != Compress::Raw::Zlib->Z_STREAM_END) {
		_die("inflate failed: $status (".$stream->msg.")");
	}

	return $outbuf;
}

sub decompress_gzip {
	my ($buf) = @_;

	return decompress_deflate($buf, is_gzip => 1);
}

sub dl_0bin {
	my ($url, $frag) = @_;

	if (!length $frag) {
		_die("cannot decrypt without key in URL fragment");
	}

	my $body = get($url);
	$body =~ m{<code>\n\s*(\{.+\})\n\s*</code>} || return;

	my $data = decode_html($1);
	$data = decrypt_sjcl($frag, $data);
	$data = decode_base64($data);
	#$data = decompress_lzw($data);
	return $data;
}

sub dl_ezcrypt {
	eval {
		require Crypt::Digest::SHA1;
	} or _die("missing Perl package 'CryptX'");

	Crypt::Digest::SHA1->import("sha1_hex");

	my ($url, $frag) = @_;

	if (!length $frag) {
		_die("cannot decrypt without key in URL fragment");
	}

	my $password;
	my $body;
	my $data;

	$body = get($url);

	while ($body =~ /<div id="askpassword">/) {
		if (-t 0) {
			_debug("paste is password-protected");
			$password = _prompt("password?");
		} else {
			_die("paste is password-protected");
		}
		$body = post($url, p => sha1_hex($password)) || return;
	}

	if ($body =~ /DOCTYPE/) {
		$body =~ m{<input .+ id="data" value="(.+)" />}s || return;
		$data = $1;
	}
	elsif ($body =~ /^\{/) {
		$data = decode_json($body);
		$data = $data->{data};
	}

	$data = decode_base64($data);
	$data = decrypt_ezcrypt($frag, $data);
	return $data;
}

sub dl_zerobin {
	my ($url, $frag) = @_;

	if (!length $frag) {
		_die("cannot decrypt without key in URL fragment");
	}

	my $body = get($url) // return;
	$body =~ m{<div id="cipherdata" style="display:none;">(.+)</div>} || return;

	my $data = decode_html($1);
	$data = decode_json($data)->[0]->{data};
	$data = decrypt_sjcl($frag, $data);
	$data = decode_base64($data);
	$data = decompress_deflate($data);
	return $data;
}

sub dl_sour {
	eval {
		require Crypt::Digest::RIPEMD160;
	} or _die("missing Perl package 'CryptX'");

	Crypt::Digest::RIPEMD160->import("ripemd160");

	my ($url, $frag) = @_;

	my $body = get($url) // return;
	my @body = split(/\n\n/, $body);

	my %headers = map {/^(\S+):\s*(.*)$/} split(/\n/, $body[0]);
	_debug("found header: $_='$headers{$_}'") for sort keys %headers;
	if ($headers{chk}) {
		my $k = decode_sour_base64($frag);
		my $c = decode_sour_base64($headers{chk});
		if (ripemd160($k) ne $c) {
			_die("decryption failed (incorrect key)");
		}
	}

	my $data = decode_base64($body[1]);
	$data = decrypt_sour($frag, $data);
	if (($headers{zip} // "") eq "True") {
		$data = decompress_gzip($data);
	}
	return $data;
}

sub parse_url {
	my ($url) = @_;
	my ($scheme, $host, $path, $query, $frag) = uri_split $url;

	_debug("scheme='".($scheme//"")."'".
		", host='".($host//"")."'".
		", path='".($path//"")."'".
		", query='".($query//"")."'".
		", frag='".($frag//"")."'");

	if (!defined($host) || !defined($path)) {
		_die("bad URL: $url");
	}

	$path =~ s|^/||;
	$query //= "";

	if ($host =~ /^sprunge\.us$/)
		{ return $url }

	elsif ($host =~ /^codepad\.org$/ and $path =~ m!^(\w+)!)
		{ return "$scheme://$host/$1/raw.txt" }

	elsif ($host =~ /^dpaste\.(org|de)$/ and $path =~ m!^(\w+)!)
		{ return "$scheme://$host/$1/raw/" }

	elsif ($host =~ /^ghostbin\.com$/ and $path =~ m!^(paste/\w+)!)
		{ return "$scheme://$host/$1/raw" }

	elsif ($host =~ /^dpaste\.com$/ and $path =~ m!^(?:hold/)?(\d+)!)
		{ return "$scheme://$host/$1/plain/" }

	elsif ($host =~ /^(?:[\w-]+\.)?pastebin\.ca$/ and $path =~ m!^(?:raw/)?(\d+)!)
		{ return "$scheme://$host/raw/$1" }

	elsif ($host =~ /^pastebin\.com$/ and $path =~ m!^(?:index/)?(\w+)!)
		{ return "$scheme://$host/download.php?i=$1" }

	elsif ($host =~ /^pastebin(\.centos|\.mozilla)?\.org$/
		and $path =~ m!^(?:pastebin\.php\?dl=)?(\d+)!)
		{ return "$scheme://$host/pastebin.php?dl=$1" }

	elsif ($host =~ /^paste\.linuxassist\.net$/ and $path =~ m!(\d+)!)
		{ return "$scheme://linux:linux\@$host/pastebin.php?raw=$1" }

	elsif ($host =~ /^pastie\.org$/ and $path =~ m!^(\d+)!)
		{ return "$scheme://$host/pastes/$1/download" }

	elsif ($host =~ /(?:dark-)?code\.bulix\.org$/ and $path =~ m!^(\w+-\d+)!)
		{ return "$scheme://$host/$1?raw" }

	elsif ($host =~ /^fpaste\.org$/ and $path =~ m!^(\w+(?:/\d+)?)!)
		{ return "$scheme://$host/$1/raw/" }

	elsif ($host =~ /^paste\.fedoraproject\.org$/)
		{ return "$scheme://$host/$path/raw" }

	elsif ($host =~ /^pastebin\.de$/ and $path =~ m!^(\d+)!)
		{ return "$scheme://$host/download/?id=$1" }

	elsif ($host =~ /^privatepaste\.com$/ and $path =~ m!^(\w+)!)
		{ return "$scheme://$host/download/$1" }

	elsif ($host =~ /^gist\.github\.com$/)
		{ return "$scheme://$host/$path.txt" }

	elsif ($host =~ /^hastebin\.com$/ and $path =~ m!^(\w+)!)
		{ "$scheme://hastebin.com/raw/$1" }

	elsif ($host =~ /^www\.dropbox\.com$/)
		{ "$scheme://dl.dropboxusercontent.com/$path" }

	elsif ($host =~ /^(www\.)?irccloud\.com$/ and $path =~ m!^pastebin/(\w+)!)
		{ "$scheme://$host/pastebin/$1.raw" }

	# cryptobins

	elsif ($host =~ /^0bin\.net$/)
		{ $url, \&dl_0bin, $frag }

	elsif ($host =~ /^ezcrypt\.it$/)
		{ $url, \&dl_ezcrypt, $frag }

	elsif ($host =~ /^sour\.is$/ and $path eq "p/" and $frag =~ m{^/(.+)!(.+)})
		{ "$scheme://sour.is/p.store/$1", \&dl_sour, $2 }

	elsif ($url =~ m{^zerobin\+(https?://.+)$})
		{ $1, \&dl_zerobin, $frag }

	elsif ($query =~ /^[0-9a-f]{16}$/ && $frag =~ m{^[0-9A-Za-z+/]{43}=$})
		{ _debug("probably a ZeroBin site based on query & fragment");
		  $url, \&dl_zerobin, $frag }

	# final

	else
		{ return undef }
}

sub usage {
	print "$_\n" for
	"Usage: $::arg0 [-u] <url>",
	"",                       #
	"  -u, --show-url         Output only the URL of raw document",
}

# Option parsing

my $insecure = 0;
my $showurl = 0;

GetOptions(
	"help"		=> sub { usage(); exit; },
	"insecure"	=> \$insecure,
	"u|show-url"	=> \$showurl,
) or exit 2;

if (!@ARGV) {
	_die("missing URL", 2);
}

if ($insecure) {
	$UA->ssl_opts(verify_hostname => 0);
}

unless ($ENV{PERL_LWP_SSL_CA_FILE} || $ENV{HTTPS_CA_FILE}) {
	$UA->ssl_opts(SSL_ca_file => "/etc/ssl/certs/ca-certificates.crt");
}

# Main code

for my $url (@ARGV) {
	my ($raw, $handler, @hargs) = parse_url($url);
	if (!defined $raw && !defined $handler) {
		_err("unknown pastebin: $url");
	} elsif ($showurl) {
		if ($handler) {
			_err("pastebin does not have raw URLs: $url");
		} else {
			print "$raw\n";
		}
	} else {
		if ($handler) {
			my $output = $handler->($raw, @hargs);
			if (defined $output) {
				print "$output\n";
			} else {
				_err("paste extraction failed");
			}
		} else {
			getprint $raw;
		}
	}
}

exit $::errors;
