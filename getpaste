#!/usr/bin/env perl
# getpaste - retrieves raw text from pastebins
#
# (c) 2010-2015 Mantas Mikulėnas <grawity@gmail.com>
# Released under the MIT license (see dist/LICENSE.mit)
use warnings;
use strict;
no locale;
use Getopt::Long qw(:config bundling no_ignore_case);
use JSON;
use LWP::UserAgent;
use MIME::Base64;

my $opt_insecure = 0;
my $opt_show_url = 0;

# generic utility functions {{{

BEGIN {
	if (eval {require Nullroute::Lib}) {
		Nullroute::Lib->import(qw(_debug _warn _err _die));
	} else {
		our ($arg0, $warnings, $errors);
		$::arg0 = (split m!/!, $0)[-1];
		$::debug = !!$ENV{DEBUG};
		sub _debug { warn "debug: @_\n" if $::debug; }
		sub _warn  { warn "warning: @_\n"; ++$::warnings; }
		sub _err   { warn "error: @_\n"; ! ++$::errors; }
		sub _die   { _err(@_); exit 1; }
	}
}

sub _prompt {
	my ($msg) = @_;

	print STDERR "\e[1m$msg\e[m "; $|++;
	chomp(my $resp = <STDIN>);
	return $resp;
}

sub _dump {
	use Data::Dumper;
	return Data::Dumper->new(\@_)->Terse(1)->Indent(0)->Dump;
}

# }}}
# URL parsing functions {{{

my $URL_RE = qr{
		(?:    (?<scheme> [^:\/?\#]+) : )?
		(?: // (?<host> [^/?#]*)        )?
		       (?<path> [^?#]*)
		(?: \? (?<query> [^#]*)         )?
		(?: \# (?<fragment> .*)         )?
	}x;

sub parse_url {
	my ($url) = @_;

	if ($url =~ $URL_RE) { return %+; }
}

sub unparse_url {
	my (%url) = @_;

	my $url = $url{scheme}."://".$url{host};
	$url .= $url{path}         if defined($url{path});
	$url .= "?".$url{query}    if defined($url{query});
	$url .= "#".$url{fragment} if defined($url{fragment});
	return $url;
}

# }}}
# translation database functions {{{

sub smart_match {
	my ($str, $pattern) = @_;

	if (!defined $str) {
		return;
	}
	elsif (ref($pattern) eq "ARRAY") {
		for (@$pattern) {
			my @res = smart_match($str, $_);
			return @res if @res;
		}
	}
	elsif (ref($pattern) eq "Regexp" && $str =~ $pattern) {
		# If $pattern has no capture groups, =~ will return an
		# (1,) in list context since it needs a trueish value.
		# This piece linenoise works consistently in all cases.
		return map {substr($str, $-[$_], $+[$_]-$-[$_])} 0..$#-;
	}
	elsif (ref($pattern) eq "" && $str eq $pattern) {
		return $str;
	}
	return;
}

my $EXPN_RE = qr/#(#|\d|\{\w+.\d+\})/;

sub expn {
	my ($str, $data, $def) = @_;

	for ($str) {
		if ($_ eq "#") {
			return $_;
		} elsif ($def && /^(\d+)$/) {
			return $data->{$def}->[$1] // "";
		} elsif (/^\{(\w+).(\d+)\}$/) {
			return $data->{$1}->[$2] // "";
		} else {
			_err("unknown expansion '#$_'");
			return "\x{1F612}";
		}
	}
};

my @SITES;

sub translate_url {
	my ($url) = @_;

	my @fields = qw(scheme host path query fragment);

	my %url = parse_url($url);

	unless (%url && defined($url{host}) && defined($url{path})) {
		_die("bad URL: $url");
	}

	_debug("scheme='".($url{scheme}//"")."'".
		", host='".($url{host}//"")."'".
		", path='".($url{path}//"")."'".
		", query='".($url{query}//"")."'".
		", frag='".($url{fragment}//"")."'");

SITE:	for my $site (@SITES) {
		use Data::Dumper;

		my %match;
		for (@fields) {
			my $pat = $site->{"$_"} or next;
			my @res = smart_match($url{$_}, $pat) or next SITE;
			_debug("match $_ ~ "._dump($pat));
			_debug(" -> "._dump(\@res));
			$match{$_} = \@res;
		}
		next if !%match;

		if ($site->{"note"}) { _debug($site->{"note"}); }

		for (@fields) {
			$match{$_} //= [$url{$_}];
		}

		for (@fields) {
			my $fmt = $site->{"to_$_"} // next;
			$fmt =~ s/$EXPN_RE/expn($1, \%match, $_)/ge;
			$url{$_} = $fmt;
		}

		my $raw_url = unparse_url(%url);
		my $func = $site->{"parser"};
		if ($func) {
			return ($raw_url, $func, $url{fragment});
		} else {
			return ($raw_url);
		}
	}
	return;
}

sub retrieve_paste {
	my ($url) = @_;

	my ($raw_url, $handler, @hargs) = translate_url($url);

	if (!$raw_url && !$handler) {
		_err("unknown pastebin: $url");
	} elsif ($opt_show_url) {
		if ($handler) {
			_err("pastebin does not have raw URLs: $url");
		} else {
			print "$raw_url\n";
		}
	} else {
		if ($handler) {
			my $output = $handler->($raw_url, @hargs);
			if (defined $output) {
				print "$output\n";
			} else {
				_err("paste extraction failed");
			}
		} else {
			getprint($raw_url);
		}
	}
}

sub dl_recursive {
	my ($url) = @_;

	my $target = follow($url);

	return retrieve_paste($target);
}

# }}}
# HTTP client functions {{{

my $UA = LWP::UserAgent->new;

sub get {
	my ($url) = @_;

	_debug("fetching '$url'");
	my $resp = $UA->get($url);

	if ($resp->is_success) {
		_debug("fetch complete: '".$resp->status_line."'");
		return $resp->decoded_content // $resp->content;
	} else {
		_err("fetch failed: '".$resp->status_line."'");
		return;
	}
}

sub getprint {
	my ($url) = @_;

	my $data = get($url);
	if (defined $data) {
		print $data;
	}
}

sub post {
	my ($url, %form) = @_;

	_debug("posting to '$url'");
	my $resp = $UA->post($url, \%form);

	if ($resp->is_success) {
		_debug("post complete: '".$resp->status_line."'");
		return $resp->decoded_content // $resp->content;
	} else {
		_err("post failed: '".$resp->status_line."'");
		return;
	}
}

sub follow {
	my ($url) = @_;

	_debug("following '$url'");
	my $resp = $UA->head($url);

	if ($resp->is_success) {
		_debug("fetch complete: '".$resp->status_line."'");
		_debug(" -> '$_'") for map {$_->request->uri} ($resp->redirects, $resp);
		return $resp->request->uri->as_string;
	} else {
		_err("fetch failed: '".$resp->status_line."'");
		return;
	}
}

# }}}
# DECRYPTORS {{{

sub decode_sour_base64 {
	my ($str) = @_;

	$str =~ y!_-!/+!;
	return decode_base64($str);
}

sub decode_html {
	my ($str) = @_;

	$str =~ s/&lt;/</g;
	$str =~ s/&gt;/>/g;
	$str =~ s/&quot;/"/g;
	$str =~ s/&amp;/\&/g;
	return $str;
}

sub try_decode_json {
	my ($data) = @_;

	return ref $data ? $data : decode_json($data);
}

sub EVP_BytesToKey {
	eval {
		require Crypt::Digest::MD5;
	} or _die("missing Perl package 'CryptX'");

	Crypt::Digest::MD5->import("md5");

	my ($salt, $passphrase, $ks, $ivs) = @_;

	my $hash = "";
	my $buf = "";

	while (length($buf) < $ks + $ivs) {
		$hash = md5($hash, $passphrase, $salt);
		$buf .= $hash;
	}

	my $key = substr($buf, 0, $ks);
	my $iv = substr($buf, $ks, $ivs);

	return ($key, $iv);
}

sub decrypt_sjcl {
	eval {
		require Crypt::AuthEnc::CCM;
		require Crypt::KeyDerivation;
	} or _die("missing Perl package 'CryptX'");

	Crypt::AuthEnc::CCM->import(":all");
	Crypt::KeyDerivation->import("pbkdf2");

	# serialization: JSON
	# key derivation: PBKDF2-SHA256
	# encryption: AES128-CCM

	my ($frag, $json) = @_;

	my $data = try_decode_json($json);

	if (($data->{v} //= "1") != 1) {
		_die("unsupported SJCL blob version ".$data->{v});
	}
	if (($data->{cipher} //= "aes") ne "aes") {
		_die("unsupported cipher ".$data->{cipher});
	}
	if (($data->{mode} //= "ccm") ne "ccm") {
		_die("unsupported mode ".$data->{mode});
	}

	my $salt = decode_base64($data->{salt});
	my $ct   = decode_base64($data->{ct});
	my $iv   = decode_base64($data->{iv});
	my $iter = int($data->{iter} || 1000),
	my $ks   = int($data->{ks} || 128) / 8; # key size
	my $ts   = int($data->{ts} || 64) / 8; # tag size
	my $hdr  = decode_base64($data->{adata} // "");

	my $key  = pbkdf2($frag, $salt, $iter, "SHA256", $ks);
	my $tag  = substr($ct, -$ts, $ts, "");

	return ccm_decrypt_verify("AES", $key, $iv, $hdr, $ct, $tag)
	       // _die("decryption failed");
}

sub decrypt_ezcrypt {
	eval {
		require Crypt::Cipher::AES;
		require Crypt::KeyDerivation;
		require Crypt::Mode::OFB;
	} or _die("missing Perl package 'CryptX'");

	Crypt::KeyDerivation->import("pbkdf2");

	# serialization: raw [salt + data]
	# key derivation: PBKDF2-SHA1
	# encryption: AES-256-OFB

	my ($frag, $data) = @_;

	my $ks   = Crypt::Cipher::AES->keysize;
	my $bs   = Crypt::Cipher::AES->blocksize;

	my $salt = substr($data, 0, $bs, "");
	my $iter = 1; # LOL
	my $key  = pbkdf2($frag, $salt, $iter, "SHA1", $ks);
	my $iv   = $salt;

	return Crypt::Mode::OFB->new("AES")->decrypt($data, $key, $iv);
}

sub decrypt_openssl {
	eval {
		require Crypt::Cipher::AES;
		require Crypt::Mode::CBC;
	} or _die("missing Perl package 'CryptX'");

	# serialization: raw [magic + salt + data]
	# key derivation: EVP_BytesToKey (MD5)
	# encryption: AES-256-CBC

	my ($frag, $data) = @_;

	my $ks    = Crypt::Cipher::AES->keysize;
	my $bs    = Crypt::Cipher::AES->blocksize;

	my $magic = substr($data, 0, 8, "");
	my $salt  = substr($data, 0, 8, "");

	if ($magic ne "Salted__") {
		_die("bad magic value in encrypted data");
	}
	my ($key, $iv) = EVP_BytesToKey($salt, $frag, $ks, $bs);

	return Crypt::Mode::CBC->new("AES")->decrypt($data, $key, $iv);
}

sub decompress_lzw {
	eval {
		require Compress::LZW;
	} or _die("missing Perl package 'Compress::LZW'");

	my ($buf) = @_;

	return Compress::LZW->decompress($buf);
}

sub decompress_deflate {
	eval {
		require Compress::Raw::Zlib;
	} or _die("missing Perl package 'Compress::Raw::Zlib'");

	my ($buf, %opt) = @_;

	my $wbits;
	my $stream;
	my $status;
	my $outbuf;

	if ($opt{is_gzip}) {
		$wbits = Compress::Raw::Zlib->WANT_GZIP;
	} else {
		$wbits = -Compress::Raw::Zlib->MAX_WBITS;
	}

	($stream, $status) = Compress::Raw::Zlib::Inflate->new(-WindowBits => $wbits);
	if ($status != Compress::Raw::Zlib->Z_OK) {
		_die("inflateInit failed: $status");
	}

	$status = $stream->inflate($buf, $outbuf);
	if ($status != Compress::Raw::Zlib->Z_OK &&
	    $status != Compress::Raw::Zlib->Z_STREAM_END) {
		_die("inflate failed: $status (".$stream->msg.")");
	}

	return $outbuf;
}

sub decompress_gzip {
	my ($buf) = @_;

	return decompress_deflate($buf, is_gzip => 1);
}

sub dl_0bin {
	my ($url, $frag) = @_;

	if (!length $frag) {
		_die("cannot decrypt without key in URL fragment");
	}

	my $body = get($url);
	$body =~ m{<code>\n\s*(\{.+\})\n\s*</code>} || return;

	my $data = decode_html($1);
	$data = decrypt_sjcl($frag, $data);
	$data = decode_base64($data);
	#$data = decompress_lzw($data);
	return $data;
}

sub dl_ezcrypt {
	eval {
		require Crypt::Digest::SHA1;
	} or _die("missing Perl package 'CryptX'");

	Crypt::Digest::SHA1->import("sha1_hex");

	my ($url, $frag) = @_;

	if (!length $frag) {
		_die("cannot decrypt without key in URL fragment");
	}

	my $password;
	my $body;
	my $data;

	$body = get($url);

	while ($body =~ /<div id="askpassword">/) {
		if (-t 0) {
			_debug("paste is password-protected");
			$password = _prompt("password?");
		} else {
			_die("paste is password-protected");
		}
		$body = post($url, p => sha1_hex($password)) || return;
	}

	if ($body =~ /DOCTYPE/) {
		$body =~ m{<input .+ id="data" value="(.+)" />}s || return;
		$data = $1;
	}
	elsif ($body =~ /^\{/) {
		$data = decode_json($body);
		$data = $data->{data};
	}

	$data = decode_base64($data);
	$data = decrypt_ezcrypt($frag, $data);
	return $data;
}

sub dl_zerobin {
	my ($url, $frag) = @_;

	if (!length $frag) {
		_die("cannot decrypt without key in URL fragment");
	}

	my $body = get($url) // return;
	$body =~ m{<div id="cipherdata" style="display:none;">(.+)</div>} || return;

	my $data = decode_html($1);
	$data = decode_json($data)->[0]->{data};
	$data = decrypt_sjcl($frag, $data);
	$data = decode_base64($data);
	$data = decompress_deflate($data);
	return $data;
}

sub dl_sour {
	eval {
		require Crypt::Digest::RIPEMD160;
	} or _die("missing Perl package 'CryptX'");

	Crypt::Digest::RIPEMD160->import("ripemd160");

	my ($url, $frag) = @_;

	my $body = get($url) // return;
	my @body = split(/\n\n/, $body);

	my %headers = map {/^(\S+):\s*(.*)$/} split(/\n/, $body[0]);
	_debug("found header: $_='$headers{$_}'") for sort keys %headers;
	if ($headers{chk}) {
		my $k = decode_sour_base64($frag);
		my $c = decode_sour_base64($headers{chk});
		if (ripemd160($k) ne $c) {
			_die("decryption failed (incorrect key)");
		}
	}

	my $data = decode_base64($body[1]);
	$data = decrypt_openssl($frag, $data);
	if (($headers{zip} // "") eq "True") {
		$data = decompress_gzip($data);
	}
	return $data;
}

sub dl_kopy {
	my ($url, $frag) = @_;

	my $body = get($url) // return;
	$body = decode_json($body);

	my $data = $body->{data};
	if (($body->{security} // "") eq "encrypted") {
		$data = decode_base64($data);
		$data = decrypt_openssl($frag, $data);
	}
	return $data;
}

# }}}
# SITE DATABASE {{{
#
# - supported match fields:
#     scheme, host, path, query, fragment
#     ('host' includes the :port if any)
#
# - each match may be a "string literal", qr/regex literal/, or [array thereof],
#
# - each match field has a corresponding 'to_*' replacement field,
#
# - replacements may use #𝒏 (#0, #1–#9) to reference capture groups of same field,
#   as well as #{field.𝒏} for capture groups of another field.

@SITES = (
	# generic (forced)
	{
		scheme => qr/^zerobin\+(.+)$/,
		to_scheme => "#1",
		parser => \&dl_zerobin,
	},
	# domain
	{
		host => "0bin.net",
		parser => \&dl_0bin,
	},
	{
		host => qr/^(dark-)?code\.bulix\.org$/,
		to_query => "raw",
	},
	{
		host => "codepad.org",
		path => qr!^/\w+!,
		to_path => "#0/raw.txt",
	},
	{
		host => "paste.debian.net",
		path => qr!^/(\d+)!,
		to_path => "/plain/#1",
	},
	{
		host => "dpaste.com",
		path => qr!^/\w+!,
		to_path => "#0.txt",
	},
	{
		host => ["dpaste.org", "dpaste.de"],
		path => qr!^/\w+!,
		to_path => "#0/raw/",
	},
	{
		host => "www.dropbox.com",
		to_host => "dl.dropboxusercontent.com",
	},
	{
		host => "ezcrypt.it",
		parser => \&dl_ezcrypt,
	},
	{
		host => ["fpaste.org", "paste.fedoraproject.org"],
		to_path => "#0/raw",
	},
	{
		host => "fpaste.org",
		path => qr!^/\w+(?:/\d+)?!,
		to_path => "#0/raw/",
	},
	{
		host => "ghostbin.com",
		path => qr!^/paste/\w+!,
		to_path => "#0/raw",
	},
	{
		host => "gist.github.com",
		to_path => "#0.txt",
	},
	{
		host => "hastebin.com",
		path => qr!^/(\w+)!,
		to_path => "/raw/#1",
	},
	{
		host => ["irccloud.com", "www.irccloud.com"],
		path => qr!^/pastebin/\w+!,
		to_path => "#0.raw",
	},
	{
		host => "kopy.io",
		path => qr!^/(\w+)!,
		to_path => "/documents/#1",
		parser => \&dl_kopy,
	},
	{
		host => "paste.lisp.org",
		path => qr!^/display/\d+!,
		to_path => "#0/raw",
	},
	{
		host => "paste.lisp.org",
		path => qr!^/\+!,
		parser => \&dl_recursive,
	},
	{
		host => "pastebin.mozilla.org",
		path => qr!^/(\d+)!,
		to_path => "",
		to_query => "dl=#{path.1}",
	},
	{
		host => "paste.opensuse.org",
		path => qr!^/(\d+)!,
		to_path => "/view/raw/#1",
	},
	{
		host => ["pastebin.ca", "www.pastebin.ca"],
		path => qr!^(?:/raw)?/(\d+)!,
		to_path => "/raw/#1",
	},
	{
		host => "pastebin.com",
		path => qr!^(?:/index)?/(\w+)!,
		to_path => "/download.php?i=#1",
	},
	{
		host => "pastebin.de",
		path => qr!^/(\d+)!,
		to_path => "/download/?id=#1",
	},
	{
		host => "pastie.org",
		path => qr!^/(\d+)!,
		to_path => "/pastes/#1/download",
	},
	{
		host => "privatepaste.com",
		path => qr!^/(\w+)!,
		to_path => "/download/#1",
	},
	{
		host => "www.refheap.com",
		path => qr!^/\d+!,
		to_path => "#0/raw",
	},
	{
		host => ["sour.is", "dn42.us"],
		path => "/p/",
		fragment => qr{^/(.+)!(.+)},
		to_path => "/p.store/#{fragment.1}",
		to_fragment => "#{fragment.2}",
		parser => \&dl_sour,
	},
	{
		host => ["ix.io", "sprunge.us"],
		path => qr!^/\w+!,
		to_path => "#0",
		to_query => "",
	},
	{
		host => "termbin.com",
	},
	# generic (wild guess)
	{
		query => qr/^[0-9a-f]{16}$/,
		fragment => qr{^[0-9A-Za-z+/]{43}=$},
		note => "probably a ZeroBin site based on query & fragment",
		parser => \&dl_zerobin,
	},
);

# }}}

sub usage {
	print "$_\n" for
	"Usage: $::arg0 [-u] <url>",
	"",                       #
	"  -u, --show-url         Output only the URL of raw document",
}

GetOptions(
	"help"		=> sub { usage(); exit; },
	"opt_insecure"	=> \$opt_insecure,
	"u|show-url"	=> \$opt_show_url,
) or exit 2;

if (!@ARGV) {
	_die("missing URL", 2);
}

if ($opt_insecure) {
	$UA->ssl_opts(verify_hostname => 0);
}

unless ($ENV{PERL_LWP_SSL_CA_FILE} || $ENV{HTTPS_CA_FILE}) {
	$UA->ssl_opts(SSL_ca_file => "/etc/ssl/certs/ca-certificates.crt");
}

$UA->agent("Mozilla/4.0 getpaste/0.42 (http://nullroute.eu.org/) ".$UA->_agent);

for (@ARGV) {
	retrieve_paste($_);
}

exit $::errors;
# vim: ts=8:sw=8:noet:fdm=marker
